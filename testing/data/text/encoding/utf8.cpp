/**
 * Copyright (C) 2020 Tristan. All Rights Reserved.
 * This file is licensed under the BSD 2-Clause license.
 * See the COPYING file for licensing information.
 */

#include "data/text/encoding/utf8.hpp"

#include <gtest/gtest.h>

namespace TextEncoding {

class UTF8Test : public ::testing::Test {
protected:
	std::array<std::string, 5> inputs = { {
		"OK",
		"Hello, World!",
		"ğŸ˜ƒ ğŸ˜­ ğŸ˜ˆ",
		"Ø¨Ø¹Ø¶ Ø§Ù„Ø£Ù…Ø«Ù„Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Øµ Ø§Ù„Ø¹Ø±Ø¨ÙŠ!",
		"WÌ¸Í†Í‚Ì‘Í‘ÍŒÌ•Ì…Í“Í‡ÌÍ…Í…Ì±Ì¤eÌ´Ì„Í€ÌŒÌ„Ì‰Ì„Ì’Í„Ì¯Ì¯Í•Ì¼Í‰iÌ·ÍÌÌ…Ì»ÍÍšÌ¥Ì§Ì¦rÌ´Ì„Ì“ÌÌÌ‰Ì‡Í€ÌƒÍƒÍœÌ—Ì Ì¹Ì®ÍšÌ¦Ì³Ì£dÌµÌÌ›ÍŠÌŠÌÌ¾Í˜Ì°Ì—Í Ì·ÌšÍ˜ÌŠÌƒÍÌ¾Ì”Ì½ÍŠÌ‘Ì£ÌªTÌ·Ì‰ÌŠÌ†Ì…Ì‡Ì£Í…Ì¢Ì®eÌ¶ÌŒÍ‘Ì¾Ì‡Ì„Ì€ÌˆÌ£Ì­Ì¯ÍÌ°ÌºÌ¹Í…ÌÌ—xÌµÌŠÌšÍ€Ì’Ì•ÌÌÌ«Ì§tÌ·ÍŒÍÌ…Ì†Ì¢",
	} };
	std::array<std::vector<Unicode::CodePoint>, 5> expectedOutputs = { {
		{ 0x4f, 0x4b },
		{ 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21 },
		{ 0x1f603, 0x20, 0x1f62d, 0x20, 0x1f608 },
		{ 0x628, 0x639, 0x636, 0x20, 0x627, 0x644, 0x623, 0x645, 0x62b, 0x644, 0x629, 0x20, 0x639, 0x644, 0x649, 0x20, 0x627, 0x644, 0x646, 0x635, 0x20, 0x627, 0x644, 0x639, 0x631, 0x628, 0x64a, 0x21 },
		{ 0x57, 0x338, 0x346, 0x342, 0x311, 0x351, 0x34c, 0x315, 0x305, 0x353, 0x347, 0x31d, 0x345, 0x345, 0x331, 0x324, 0x65, 0x334, 0x304, 0x340, 0x30c, 0x304, 0x309, 0x304, 0x312, 0x344, 0x32f, 0x32f, 0x355, 0x33c, 0x349, 0x69, 0x337, 0x35d, 0x30d, 0x305, 0x33b, 0x34d, 0x35a, 0x325, 0x327, 0x326, 0x72, 0x334, 0x304, 0x313, 0x30e, 0x30e, 0x309, 0x307, 0x340, 0x303, 0x343, 0x35c, 0x317, 0x320, 0x339, 0x32e, 0x35a, 0x326, 0x333, 0x323, 0x64, 0x335, 0x30f, 0x31b, 0x34a, 0x30a, 0x30f, 0x33e, 0x358, 0x330, 0x317, 0x34d, 0x20, 0x337, 0x31a, 0x358, 0x30a, 0x303, 0x350, 0x33e, 0x314, 0x33d, 0x34a, 0x311, 0x323, 0x32a, 0x54, 0x337, 0x309, 0x30a, 0x306, 0x305, 0x307, 0x323, 0x345, 0x322, 0x32e, 0x65, 0x336, 0x30c, 0x351, 0x33e, 0x307, 0x304, 0x300, 0x308, 0x323, 0x32d, 0x32f, 0x34e, 0x330, 0x33a, 0x339, 0x345, 0x31d, 0x317, 0x78, 0x335, 0x30a, 0x31a, 0x340, 0x312, 0x315, 0x310, 0x30e, 0x32b, 0x327, 0x74, 0x337, 0x34c, 0x35d, 0x305, 0x306, 0x322 },
	} };
	std::array<UTF8, 5> encoders;
};

TEST_F(UTF8Test, ValidInputs) {
	ASSERT_EQ(inputs.size(), encoders.size());
}

TEST_F(UTF8Test, NormalDecoding) {
	for (size_t i = 0; i < inputs.size(); i++) {
		ASSERT_TRUE(encoders[i].Decode(inputs[i].c_str(), inputs[i].length()))
			<< "Decode() failed on string: \"" << inputs[i] << '"';

		ASSERT_EQ(encoders[i].Output.size(), expectedOutputs[i].size())
			<< "Incorrect output size for string: \"" << inputs[i] << '"';

		for (size_t j = 0; j < encoders[i].Output.size(); j++) {
			ASSERT_EQ(encoders[i].Output[j], expectedOutputs[i][j])
				<< "Incorrect decoding of string: \"" << inputs[i]
				<< "\", the " << j << "th character is incorrect.";
		}
	}
}

} // namespace TextEncoding

int
main(int argc, char **argv) {
	::testing::InitGoogleTest(&argc, argv);
	return RUN_ALL_TESTS();
}
